1000 do rekurze by mohlo stacit?

min prasacky parametry

Parsovani zdrojaku
- procistit parser.c, funkce.c

Rozhodnout kdy/jak resolvovat

nefunguje [def ahoj[n] n] <~ treba nahradit za ~> [def ahoj [n] n] 

Vnitrni funkce - napriklad:
--------------
[def a [b]
	[def c [n] [+ b n]]
	[c b]
]

By se melo prelozit jako
[def a [b]
	[def c [b] [lambda [n] [+ b n]]]
	[c b]
]

- Nemelo by zaviset na poradi definice funkce!

NEFUNGUJE:
[def a [] [+ 1]]
[def b [] [a 2]] // zde mozna radsi [[a] 2], ale stejne to nejde
[b] ma byt 3
[a 1] ma byt 2, vrati funkci s jednim dopnenym parametrem a to jedickou

[[+ 1 2] 3] ~> 6, ma byt Error, protoze [1] je taky Error
^^^^ asi stejna chyba

[def main [] ]
[main] -> segfault

[def a [] 3]
[a] ~> 3 OK
[[a]] ~> 3 WTF??
[[a] 2] ~> 3 WTF??

----------------------------------------------

stav sveta - jak na nej?
porovnavani symbolu v konstatnim case

prace s prameti a GC

rozmyslet zda nema byt u Tanku i aktualni pocet parametru
= rychlejsi pri porovnavani zda je to jeste tank, nebo vysledek tanku
= pomalejsi pri pripojovani parametru, ale stejne se tenhle pruchod musi provist
  takze se mozna vlastne provede dopredu

Slozitejsi GC:
	http://bredy.vyletnici.net/?g=clanek&c=239

kouknout se na isatty - vstup z terminalu/standartni

----------------------------------------------
Bonus
defm = definice memorizovane funkce u ktere se pamatuji vysledky


Funkce apply!
(define a '(1 2 3 4))

(apply + a)

----------------------------------------------

Co tohle?

Viceparametrove:
[def call [funkce &parametry]
	[funkce parametry]
]

(define ((add a) b) (+ a b))
(define (add a) (lambda (b) (+ a b)))

List comprehension
	http://en.wikipedia.org/wiki/List_comprehension

Clojure
	http://clojure.org/functional_programming

nil - means false or empty list

True/false funkce s otaznikem? (null? (list ))
----------------------------------------------

TODO pocitat s tim, ze v Tanky je treba resit (s vyjimkou volani funkce)
	az v teto nejnizsi urovni. Je treba to napsat vic obecne, aby se mohlo
	pracovat i s mnozinama, cislama a podobnejma vecma jednotne.
	(Pri reseni tanku)

Vrstvy:
	- zavolani funkce s danymi parametry
	- sestaveni tela funkce a doplneni parametru kde je to nutne
	- zjisteni zda neni funkce tank, pokud jo, hazet do nej parametry
	  a volat jej dokud neni funkce nebo blbost -> error
	  (pokud se jedna o tank tak vyreseni zda je to vubec funkce)
	- vraceni tanku s volanim ziskane funkce a zbyvajicimi parametry

Tohle cele provadet tak dlouho dokud se nevrati neco co neni tank
